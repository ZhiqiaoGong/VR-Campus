[TOC]

# VRCampus

## 项目结构总览

### 根游戏对象

如[漫游系统](漫游系统 7.11.xmind)（下简称”系统“）所示，项目分成游戏对象（黑）与 “信息“” （黄）。负责人可以为该游戏对象设计任意子对象，但根对象必须遵循如下命名，并设置”tag“以供其他游戏对象搜索：

* （师姐）全景视频模块 -- [VRPlayer](###VRPlayer)
* （丁子星、陈然）二维地图模块 -- [GuideBook](###GuideBook)
* （师姐）vive头盔捕捉 -- [VVHunter](###VVHunter)
* （龚之俏、董欣欣）位置逻辑图 -- [LgGraph](###LgGraph)
* （李卓栋，下简称“我”）数据库交互模块 -- [Dao](###Dao)
* （李卓栋）节点行为 -- [Fork](###Fork)
*   (共同编辑)  调试信息 -- [Debuglog](###Debuglog) 

各模块负责人需完善负责模块的**基本功能介绍**、**接口文档**等内容的撰写。



### ”信息“——Output

“信息”，即系统中的黄色节点，指根游戏对象需要维护并向其他根游戏对象提供的数据/接口（目前只有全景视频模块不需要向其他模块输出）。”信息“以**根节点的Output组件**形式存储。每个模块的负责人需用脚本自定义这个组件。组件命名固定为： {根对象名}Output ，例如 Dao的Output组件将被命名为 ”DaoOutput“。

* 注意是~Output，每一个字母都不能错！
* 信息包括数据与接口。数据即Output组件中的公有成员变量；接口即Output组件中的公有成员函数
* Output组件必须在该模块中最晚更新。模块内各组件的更新时间由负责人自行协调，但负责人需在接口文档中列出Output的更新时间



### 模块（根游戏对象）间的交互规范（待完善）

基于上述项目结构，各模块进行交互的程序如下：

#### 使用其他模块提供的”信息“

* 查阅接口文档，确认其Output组件的更新时间是否先于自己模块。

* 查阅其对应的接口文档中的数据或接口
  * 如果是数据，确定其在每一帧中的更新时间
  * 如果是接口
    * 明确接口功能
    * 确定传入、传出参数类型、限制
* 在脚本中访问对应根游戏对象的Output组件
  * 使用数据/接口
  
* 如果未找到需要的接口或数据时，与相应的负责人协商是否需要增加这一实现。

#### 撰写负责模块的接口文档

由于我们是多人协作，并且是线上协作，并且各模块功能相对独立，因此有必要为自己模块写一份说明书，也就是接口文档。接口文档描述了<ModuleName>Output

* 数据
  * 指明数据类型，如果必要，指明范围
  * 指明数据作用
  * 如果数据在每一帧中都有更新，指明数据更新时间
* 接口
  * 指明传入、传出参数类型
  * 指明参数限制
  * 简要介绍指明参数
* 设置自己模块Output组件的更新时间。

可以参考Unity Scrip ApI文档的撰写格式。参考链接为**GameObject**的接口文档

初始化时间可在脚本文件对应的.meta文件中设置，也可以在unity中的edit内设置

[参考](https://docs.unity3d.com/ScriptReference/GameObject.html)



## 项目目录设置



*考虑到咱们大多都是第一次多人协作开发，可能对于冲突、合并、版本控制等方面的细节不大了解。其实这些都是一个多人开发团队必须面对的问题。
这些细节大家先不了解也罢，但在开发前，**请大家务必遵循这一节的目录设置的规定**，否则容易带来混乱与冲突。
当然，还是建议大家了解一下[版本控制](https://git-scm.com/book/zh/v2/%E8%B5%B7%E6%AD%A5-%E5%85%B3%E4%BA%8E%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6)。链接是git的官文，有一份翻译质量很高的中文文档（比这两天看的unity和MSDN的文档好多了！！）*



我们做的东西基本存放在Assets中。Unity对Assets下的目录有自己的一套命名规则，对于一些特殊名的目录，unity会赋予特殊的作用。详见官文[特殊文件夹名称](https://docs.unity3d.com/2018.4/Documentation/Manual/SpecialFolders.html)。（有中文版但翻译有点问题）。在这一前提下，我们托管到线上的项目的目录结构如下

* Assets

  * Plugins

    存放插件

  * Scenes

    存放场景。目前我们只有一个场景

  * StreamingAssets

    * database

      存放数据库文件

  * VRCModules（相当于我们主要的工作区）

    * 模块名（例如Dao）

      * Prefabs

        该模块用到的预设

      * Scripts

        该模块用到的脚本
    
      * ...（模块负责人自己设置的其他子文件夹）

* Packages

* ProjectSettings

* 接口文档

  存放我们的一些文档之类的，比如你现在看到的文档

**总得来说就是，各模块独立使用的资源、脚本等，放在VRCModules下的各个以模块名来命名的文件夹（下称模块文件夹）中——一般来说，各模块负责人做出的所有更改都只局限于这个文件夹。对于不在你的模块文件夹中的文件的修改务必谨慎些，并且你得明确你自己在干什么**。

在每一次更新之后，如果你的这次更新只修改了你的模块文件夹，你可以把你的模块文件夹打包给我，我来帮你提交更新；在此之前，保证你的模块可以独立、正常运行！！

你可以任意地设置、命名你的模块文件夹下的子文件，但注意不要触碰到unity的关键词。

每次你需要拉取当前最新的项目时（比如和你合作的那个模块更新了一个接口，你要用那个接口就得把上述整个项目下载下来（如果你用git就只要pull就行，线上放的一直都是主分支），然后再在新项目中你的模块文件夹里更新你的模块



ps：\*.meta文件里面存的是元数据，很重要！不能随便改





## 各模块接口文档

### GuideBook

* 简介

  接收：
   一、LgGraph
    1、GetPosition（）实时得到用户位置信息，要用到用户所在路径的起点终点编号，朝向，Location（即一条路径走的多少）

  二、Dao
   1、GetNode（）获取所有节点的列表信息

  实现功能：
   1、通过编号得到终点起点坐标，计算移动路径
   2、通过Location、朝向，实时更新光标（用户）的位置
   3、运行时，点击小地图和大地图右上角进行大小地图的切换
   4、运行开始后根据GuiBook_button脚本计算出大地图中每个节点的坐标并可视化在大地图中
  计划实现功能：
   1、点击大坐标中的可视化点系统跳到对应的场景（已实现点击功能，还未完成与LgGraph的接口交互）
   2、将二维地图位置正确调整至三维场景中
   3、根据可视化点的坐标可视化出相应路径，点击该路径，系统跳至对应路径的起点

  输出：无



### VVHunter

**VVHunter**

在每一帧中获取用户的朝向信息，朝向信息用四元数/欧拉角表示。

**VVHunterOutput**

实时提供头盔的位置和旋转角度如下：

头盔相机位置：(pos_X, pos_Y, pos_Z)

头盔相机旋转角度：(rot_X, rot_Y, rot_Z)

 

### VRPlayer

**VRPlayer**

在每一帧中，全景视频在每一次update()中从位置逻辑图中的用户当前位置信息（Position）得到该帧处于哪段视频中的哪一帧并进行播放，集成重定向算法方便用户佩戴头盔进行漫步体验。

**MediaPlayer**

playTime()：获取位置逻辑图中的位置信息并计算视频帧数，该函数放到update()中；

**ChangePath**

LoadVideo(string filePath):获取位置逻辑图中的位置信息并得到视频路径，根据路径加载对应的视频，该函数放到update()中；

**TestBorder**

重定向算法：在体验者所在的camera加一个父节点，当体验者走到体验空间预设边界转身之后使camera转动180度（假设体验者转身角度为180度），现在体验者看到的是转身前背后的场景，所以需要将父节点也转动相对应的角度，就可以将其抵消掉，这样一来即实现了视野范围不变，而且场景中心位置不会改变，无论转身多少次都能够保证场景的中心点不发生改变，所以体验者的视野不会因为场景中心点的改变而扭曲。

if(camer1.transform.localPosition.x>=border||camer1.transform.localPosition.x<=-border|| camer1.transform.localPosition.z >= border || camer1.transform.localPosition.z <= -border)://检测体验者到达边界

ControllCam(Transform camFather, Transform cam, float targetAngle, Vector2 targetPositionXZ):父节点相机旋转

**FollowCamera**

播放全景视频的球体与用户头盔的相机位置同步，防止用户走出球面





### LgGraph

接收来自数据库的信息，初始化一个逻辑地图（加权无向图，用邻接矩阵保存）。同时，接收来自头盔的运动位置及方向信息，以及二维地图的节点点击信息，保存为用户当前所处位置。

向其他模块提供接口，包括读取以及修改用户所在位置、获取相邻节点等。

**接收数据：**

1. Dao

   调用DaoOutput接口GetPathDatas()、GetNodes()获取所有路径和节点信息，用以初始化逻辑地图。

2. VVHunter

   获取VVHunterOutput中记录头盔位置、相机旋转角度的变量：pos_X,pos_Y,pos_Z,及rot_X,rot_Y,rot_Z。

**实现功能：**

1. 初始化逻辑地图，可以使用id查询节点，使用节点查询路径，与LgGraphOutput接口对应。
2. 每次Update()时获取VVHunterOutput中的信息，更新用户所在位置。
3. 当调用ChangePosition(Node nodeToGo)方法时，通过提供的节点搜索其所在路径并更新用户所在位置。

**LgGraphOutput接口：**

- Position GetPosition()

  - 返回参数：当前用户当前所处位置信息。

- void ChangePosition(Position p)

  修改用户当前所处位置信息

  - 传入参数：修改后的位置信息。

- void ChangePosition(int nodeToGo)

  修改用户当前所处位置信息

  - 传入参数：要前往的节点id。

- void ChangePosition(PathData pathToGo, float rate)

  修改用户当前所处位置信息，用于用户点击路径上的任意点时

  - 传入参数：用户点击的路径，用户点击路径的位置。

- List<Node> GetAdjacencyNodes(int id)

  搜索一个节点的所有的邻接节点

  - 传入参数：当前节点的节点序号。
  - 返回参数：当前节点的所有邻接节点。

- Node getNodeById(int id)

  用节点id值搜索节点

  - 传入参数：节点id。
  - 返回参数：完整节点信息。

- PathData GetPathbyIDs(int id1, int id2)

  用路径两端的节点id搜索路径

  - 传入参数：路径两端节点。
  - 返回参数：完整路径信息。



### Dao

将数据库内的数据载入内存，供需要图结构的模块初始化。请尽量不要在\*Update()中调用使用此类中的函数，避免不必要的开销。

**BaseDao**

处理与数据库的连接、访问。外部无需了解其中的细节。

**DaoOutput**

向外部提供一些访问数据库的接口

接口

* List\<PathData\> GetPathDatas();
  
* 返回参数：数据库内所有路径信息
  
* List\<Node\> GetNodes();
  
* 返回参数：数据库内所有节点信息
  
* List\<Node\> GetAdjacencyNode(int id)

  搜索一个节点的所有的邻接节点。

  * 传入参数：当前节点的节点序号。
  * 返回参数：当前节点的所有邻接节点。

* List\<PathData\> GetAdjacencyPath(int id)

  搜索以一个节点与其所有邻接节点的路径

  * 传入参数：当前节点节点序号
  * 返回参数：节点与其所有邻接节点的路径[^1]

[^1]: 节点不一定是起点。以该节点为终点的路径也会被放入List

* PathData GetPath(int A,int B);

  搜索两个节点之间的路径信息

  * 传入参数：两个节点的节点序号（无顺序要求）

  * 返回参数：两个节点之间的路径信息

    如果不存在，返回null。

* void testDao()

  测试接口是否正常。



### Fork

处理用户在节点处的行为



**主要脚本**

**ForkOutput**

* 接口
  * ChangePath()

    此函数将会根据当前用户头盔的转向角度，推测用户希望转向的路径，并将新的位置信息作为请求参数，请求lggraph模块更改。

* Update

  每一帧中检测用户是否到达了节点。如果到达，将调用函数ChangePath

**AngleCaculator**

节点偏角的计算类。

其构造函数的参数为一个Node，构造出来的实例会以此Node作为出发点，记为root_node。

构造函数同时会以root_node为参数调用CoordinateTranformer的构造函数，得到一个coordinate，coordinate将负责经纬度与平面坐标的转化

* 接口

  * getAngleList

    获取一系列节点与本实例的根节点连线与正东方向的夹角。传入参数中的所有节点的经纬度属性为初值。返回的角度为度数制（0—360度）

  * getAngle

    根据两个节点返回两个节点的夹角



### 	DebugLog

方便调试时查看一些数据的变化。任何人都可以在上面进行编辑，加入你在调试时像看到的参数即可。但为了区分，请将输出放到不同组件上



















